[{"title":"Java 基础教程","url":"/2025/04/26/%E5%90%8E%E7%AB%AF/java/java%E5%9F%BA%E7%A1%80/","content":"练习1:杨辉三角import java.util.Arrays;//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=&quot;Run&quot;/&gt; or// click the &lt;icon src=&quot;AllIcons.Actions.Execute&quot;/&gt; icon in the gutter.public class Main &#123;    public static void main(String[] args) &#123;        int numberOfRows = 9;        int[][] yangHuiTriangle = new int[numberOfRows][];        yangHuiTriangle[0] = new int[1];        yangHuiTriangle[0][0] = 1;        for (int i = 1; i &lt; numberOfRows; i++) &#123;            yangHuiTriangle[i] = new int[i + 1]; // 初始化当前行            for (int j = 0; j &lt; i; j++) &#123;                if (j == 0 || j == i - 1) &#123;                    yangHuiTriangle[i][j] = 1;                    continue;                &#125;                yangHuiTriangle[i][j] = yangHuiTriangle[i - 1][j - 1] + yangHuiTriangle[i - 1][j];            &#125;        &#125;        for (int[] row : yangHuiTriangle) &#123;            for (int element : row) &#123;                if (element == 0) continue;                System.out.print(element + &quot; &quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;\n\n在写杨辉三角案例的时候发现了一个二维数组初始化的问题。\n如果只初始化行的话, 二维的数组默认值是null\nint numberOfRows = 5; // 例如5行int[][] yangHuiTriangle = new int[numberOfRows][]; // 只初始化行yangHuiTriangle[0][0] = 1;\n\n如果不初始化就进行赋值的话就会报错\nException in thread &quot;main&quot; java.lang.NullPointerException: Cannot store to int array because &quot;yangHuiTriangle[0]&quot; is null\tat Main.main(Main.java:10)\n\n所以必须初始化之后在进行赋值\nint numberOfRows = 5; // 例如5行int[][] yangHuiTriangle = new int[numberOfRows][]; // 只初始化行yangHuiTriangle[0] = new int[1];yangHuiTriangle[0][0] = 1;\n\n随机数在java中有常见的两种生成随机数的方法是Math.random() 和java.util.Random类\n1. 基本用法Math.random() 方法功能: 生成[0.0,1.0)范围内的double类型的伪随机数,线程安全的\n语法:Math.ranndom()\n// 0-100int randomInt = (int)(Math.random() * 100)    // 1-30int randomInt = (int)(Math.random() * 30) + 1// 生成 [5, 20] 的随机整数（通用公式）int min = 5, max = 20;int randomInt = (int) (Math.random * (max - min + 1)) + min\n\njava.util.Random 类1. 基本用法\n功能：生成多种类型的随机数（整数、浮点数、布尔值等）。线程不安全\n语法：\n\nRandom random = new Random(); // 默认种子为系统时间Random seededRandom = new Random(123L); // 指定种子\n\n2. 核心方法\n\n\n方法\n返回值\n范围\n\n\n\nnextInt()\nint\n所有可能的 int 值\n\n\nnextInt(int bound)\nint\n[0, bound)\n\n\nnextDouble()\ndouble\n[0.0, 1.0)\n\n\nnextBoolean()\nboolean\ntrue 或 false\n\n\nnextLong()\nlong\n所有可能的 long 值\n\n\n练习2:随机赋值创建一个长度为6的int型数组，要求数组元素的值都在1-30之间， 且是随机赋值。同时，要求元素的值各不相同。\nint[] arr = new int[6];for(int i = 0; i &lt; arr.length; i++)&#123;    for(int j = 0; j &lt; i; j++)&#123;        if(arr[i] == arr[j])&#123;            i--;            break;        &#125;    &#125;&#125;\n\n练习3:遍历扑克牌import java.util.Arrays;public class Main &#123;    public static void main(String[] args) &#123;        String[] suit = new String[]&#123;&quot;♣&quot;, &quot;♦&quot;, &quot;♥&quot;, &quot;♠&quot;&#125;;        String[] scores = new String[]&#123;&quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;, &quot;A&quot;, &quot;2&quot;&#125;;        String[] poker = new String[56];        int total = 0;        for (int i = 0; i &lt; suit.length; i++) &#123;            for (int j = 0; j &lt; scores.length; j++) &#123;                poker[total++] = suit[i] + scores[j];            &#125;        &#125;        poker[total++] = &quot;Big Joker&quot;;        poker[total++] = &quot;Little Joker&quot;;        for (int i = 0; i &lt; total; i++) &#123;            if (i % 13 == 0 &amp;&amp; i != 0) &#123;                System.out.println();            &#125;            System.out.print(poker[i] + &quot; &quot;);        &#125;    &#125;&#125;\n\n练习4: 螺旋矩阵思路分析1. 螺旋矩阵的特点\n螺旋矩阵是指数字从外向内顺时针螺旋排列方阵.\n我们来拿4 * 4的方阵举例\n1 → 2 → 3 → 4           ↓12 →13 →14  5↑        ↓  ↓11  16 ←15  6↑           ↓10 ←9 ←8 ←  7\n\n2. 实现思路\n我们采用”边界收缩法”来实现\n\n定义四个边界 top, bottom, left, right\n按照”上边 -&gt; 右边 -&gt; 下边 -&gt; 左边”的顺序来填充\n每填充完一条边,对应的边界像内搜索\n重复此过程直到所有数字填完\n\n\n我们先来定义一个nxn的二维数组来存放数据\n\nn = 4int num = 1;int[][] arr = new int[n][n]\n\n\n我们来定义4条边界\n\nint top = 0, bottom = n -1, left = 0, right = n -1\n\ntop &#x3D; 0 代表上边界的第0行\nbottom &#x3D; 0 代表下边界的 最后一行\nleft &#x3D; 0  代表左边界的第 0 列\nright &#x3D; n -1 代表 右边的最后一列\n\n定义循环控制条件\n\nwhile (num &lt;= n * n) &#123;&#125;\n\n\n从左向右填充\n\nfor(int i = left; i &lt;= right;i++)&#123;  \t\tarr[left][i] = num++;&#125;  \ttop++\n\n此时我们就完成了从左到右的填充\n[​\t[1, 2, 3, 4],​   [0, 0, 0, 0], ←  top++ 将移动到这行​   [0, 0, 0, 0],​   [0, 0, 0, 0]]top++ \n\n\n从上到下填充\n\nfor(int i = top; i &lt;= bottom;i++)&#123;  \t\tarr[i][right] = num++;  \t&#125;right--\n\n此时就完成了从上到下的填充\n[​\t[1, 2, 3, 4],​   [0, 0, 0, 5], ​   [0, 0, 0, 6],​   [0, 0, 0, 7]\t\t   ↑ \t\t   right-- 此时就指向了这一列]\n\n\n从右到左填充\n\nfor(int i = right; i &gt;= left; i--)&#123;     arr[bottom][i] = num++;&#125;bottom--;\n\n此时就完成了从右到左的填充\n[​\t\t                     [1, 2, 3, 4],​  \t\t                     [0, 0, 0, 5], ​  bottom--之后指向的位置     → [0, 0, 0, 6],  ​                            [10, 9, 8, 7]]\n\n\n从下到上填充\n\nfor(int i = bottom; i &gt;= top; i--)&#123;     arr[i][left] = num++;&#125;left++;\n\n此时就填充完了一圈\n[​\t\t[1, 2, 3, 4],             ↓ 此时的left ++  ​  \t\t[12, 0, 0, 5], ​ \t\t[11, 0, 0, 6],  ​       [10, 9, 8, 7]]\n\n在填充 n轮后 到达 边界检测条件后就完成了填充 \nwhile (num &lt;= n * n) &#123;&#125;\n\n完整代码\npublic class Main &#123;    public static void main(String[] args) &#123;        int n = 4;        int[][] arr = new int[n][n];        int num = 1;        int top = 0, bottom = n - 1, left = 0, right = n - 1;        while (num &lt;= n * n) &#123;            for (int i = left; i &lt;= right; i++) &#123;                arr[top][i] = num++;            &#125;            top++;            for (int i = top; i &lt;= bottom; i++) &#123;                arr[i][right] = num++;            &#125;            right--;            for (int i = right; i &gt;= left; i--) &#123;                arr[bottom][i] = num++;            &#125;            bottom--;            for (int i = bottom; i &gt;= top; i--) &#123;                arr[i][left] = num++;            &#125;            left++;        &#125;    &#125;&#125;\n\n这套实现方法有局限性只能 做固定起点、固定顺时针的矩阵填充,不能做动态方向&#x2F;中心扩展&#x2F;不规则矩阵&#x2F;变化版螺旋布局\n第二套实现方案方向数组 + 步长控制\n","categories":["Backend","Java"],"tags":["技术","后端","查缺补漏","基础"]}]