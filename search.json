[{"title":"java 常见算法","url":"/2025/04/27/backend/java/java%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/","content":"一、通用基础\n时间／空间复杂度分析\n熟练掌握 O(1)、O(log n)、O(n)、O(n log n)、O(n²) 等常见复杂度，并能针对业务场景做权衡。\n\n\n常见数据结构\n数组、链表、栈、队列、哈希表（HashMap）、堆（优先队列）、树（尤其是二分搜索树、B-树&#x2F;B+ 树）、图。\n\n\n排序与查找\n快速排序、归并排序、堆排序、二分查找，以及在特定场景下的稳定排序（如归并、插入排序）。\n\n\n\n时间／空间复杂度分析O(1) - 常数时间含义：执行时间不随数据量的变化而变化。每次操作都是固定的时间。\n\n业务推荐：\n数组和哈希表查找：例如在缓存中查找用户信息、通过ID访问数据库记录。\n栈和队列的操作：例如任务调度系统的入队和出队操作。\n获取当前时间或状态：例如获取当前的系统时间、获取某个全局状态。\n\n\n适用场景：\n数据结构操作：如果你需要在常数时间内完成查找、插入或删除，选择哈希表或数组。\n简单数据访问：访问数组中的特定位置，或哈希表中某个键值对。\n\n\n\nO(log n) - 对数时间含义：执行时间随着数据量的增加呈对数级别增长，通常出现在分治算法中。\n\n业务推荐：\n二分查找：例如在电商平台中快速查找商品（数据有序时）。\n平衡二叉树操作：如AVL树、红黑树等，适用于数据库索引、内存中的有序数据结构。\n堆：如优先队列，适用于任务调度系统，处理具有优先级的任务。\n\n\n适用场景：\n快速查找：当数据已经排序时，使用二分查找。\n动态数据存储：当需要频繁查找、插入、删除有序数据时，使用平衡二叉树。\n调度系统：任务优先级处理时使用堆。\n\n\n\nO(n) - 线性时间**含义：执行时间随着数据量的增大成线性关系。\n\n业务推荐：\n遍历数据：例如遍历订单列表或用户列表，进行一些统计、修改等操作。\n线性查找：如在无序数组中查找某个元素。\n数据统计：如计算总销量、统计订单数量等。\n\n\n适用场景：\n数据遍历和处理：如果你需要访问每一个元素并进行处理，选择 O(n) 的算法（如遍历数组、链表等）。\n无序数据查找：例如在用户列表中查找指定用户。\n\n\n\nO(n log n) - 线性对数时间含义：执行时间随着数据量的增加成对数级别增长，通常适用于高效排序或分治算法。\n\n业务推荐：\n高效排序：如快速排序、归并排序，用于大规模数据的排序（如商品排序、订单排序等）。\n合并操作：例如将两个有序的数据源合并成一个有序数据。\n图算法：某些图算法（如 Dijkstra 算法）用 O(n log n) 复杂度处理最短路径问题。\n\n\n适用场景：\n大规模排序：当数据量较大时，需要高效的排序算法（如快速排序、归并排序）。\n合并两个数据集：当需要将两个有序数组或链表合并时，采用合并排序等方法。\n\n\n\nO(n²) - 二次时间含义：执行时间随着数据量的增加呈二次增长，通常出现在嵌套循环中。\n\n业务推荐：\n暴力排序：如冒泡排序、插入排序、选择排序，这些算法适用于数据量较小的场景。\n矩阵运算：如矩阵乘法的传统算法，或二维数组遍历。\n图的邻接矩阵表示：对于图的操作，如果使用邻接矩阵存储图的边，某些操作（如遍历节点）会导致 O(n²) 时间复杂度。\n\n\n适用场景：\n小规模数据排序：当数据量较小（比如少于1000个数据），使用 O(n²) 的暴力算法是可行的。\n二维数据结构操作：处理二维数组、矩阵时会涉及 O(n²) 时间复杂度。\n\n\n推荐：对于大数据量，建议避免 O(n²) 算法，尤其是排序操作，可以考虑 O(n log n) 的高效算法。\n\nO(n³) - 三次时间含义：执行时间随着数据量的增大呈三次增长，通常出现于处理三维数据的场景。\n\n业务推荐：\n三维矩阵计算：如三维数组的操作或图形处理中的某些算法。\n复杂的图算法：一些特定的图算法，如果图的规模较小，可能采用三次时间复杂度。\n\n\n适用场景：\n矩阵运算：如果需要进行三维矩阵运算，或者涉及到多个嵌套循环的复杂运算时，时间复杂度为 O(n³)。\n全局优化问题：比如在一些复杂的全局优化问题中，暴力求解可能涉及三重循环，时间复杂度为 O(n³)。\n\n\n推荐：尽量避免使用 O(n³) 的算法，尤其是当数据量较大时，考虑是否有优化的解法。\n\nO(2^n) - 指数时间含义：执行时间随着数据规模的增加呈指数增长，通常出现在递归算法中，尤其是穷举型的算法。\n\n业务推荐：\n递归解法：例如斐波那契数列的递归解法、旅行商问题的暴力解法。\n暴力破解：在解某些组合优化问题时，穷举所有可能解的情况，时间复杂度为 O(2^n)。\n\n\n适用场景：\n小规模问题的递归解法：对于数据量较小的组合优化问题，如求解旅行商问题时，递归穷举可能可行。\n小规模的递归分支问题：如树形结构的递归遍历等。\n\n\n推荐：对于大规模数据，避免使用 O(2^n) 算法。需要优化时，可以考虑使用动态规划、贪心算法等更高效的算法。\n\nO(n!) - 阶乘时间含义：执行时间随着数据量的增加呈阶乘增长，通常用于处理排列问题。\n\n业务推荐：\n全排列问题：如生成所有可能的任务调度顺序、排列组合。\n解空间树的遍历：某些复杂的组合问题，暴力求解需要遍历所有可能的解空间，导致阶乘时间复杂度。\n\n\n适用场景：\n排列组合问题：如果你需要列举数据的所有排列、组合，可能会用到 O(n!) 算法。\n小规模优化问题：例如小规模的任务调度优化问题，需要暴力搜索最优解。\n\n\n推荐：对于大规模问题，避免使用 O(n!) 算法。可以使用启发式算法或动态规划来优化解法。\n\n总结\nO(1)：适用于需要快速查找或修改单一元素的场景，如缓存、栈和队列。\nO(log n)：适用于查找、插入和删除有序数据，推荐使用二分查找、平衡树等。\nO(n)：适用于遍历数据、进行数据统计等场景，选择线性时间算法。\nO(n log n)：适用于高效排序、大规模数据处理，推荐使用快速排序、归并排序。\nO(n²)：适用于小规模数据的暴力算法、二维数据结构处理，避免大数据量时使用。\nO(n³)：适用于三维数据处理、复杂图算法，但避免大规模数据时使用。\nO(2^n)：适用于小规模递归解法或暴力破解问题，大规模数据时需要优化。\nO(n!)：适用于全排列问题、小规模的组合问题，大数据量时不可行。\n\n通过结合业务场景和算法特点，你可以根据需求快速找到合适的算法，在项目中做出合理的选择。\n\n二、前端需关注的算法\nDOM 树&#x2F;虚拟 DOM 差分算法\nReact、Vue 等前端框架的核心，通过递归或键值映射实现最小化的 DOM 更新。\n\n\n节流（Throttle）与防抖（Debounce）\n优化高频操作（resize、scroll、input 等）的触发频率，降低渲染压力。\n\n\n动画与缓动函数（Easing）\n常见缓动公式（linear、ease-in&#x2F;out、cubic-bezier 等），以及基于 requestAnimationFrame 的帧率控制。\n\n\n路径查找（可选，用于游戏&#x2F;可视化）\nA*、Dijkstra 算法，用于前端可视化或游戏中的路径规划。\n\n\n前端缓存策略\nLRU（最近最少使用）、LFU（最不常用）缓存淘汰策略，在 Service Worker 或内存缓存中应用。\n\n\n加密／哈希\nMD5、SHA 系列（用于数据完整性校验）、Base64（简单编码），以及对称／非对称加密（Web Crypto API）。\n\n\n\n\n三、后端需掌握的算法\n负载均衡算法\n轮询（Round Robin）、加权轮询、最少连接、IP Hash，以及一致性哈希（Consistent Hashing，用于分布式缓存如 Redis Cluster）。\n\n\n缓存淘汰策略\nLRU、LFU、TTL（时效失效）等，在 Redis、Memcached、CDN 缓存设计中非常重要。\n\n\n数据库索引与查询优化\nB+ 树、哈希索引；查询执行计划分析；事务隔离与并发控制（两段锁、MVCC）。\n\n\n分布式一致性 &amp; 共识算法\nPaxos、Raft，用于分布式存储系统（Etcd、ZooKeeper）。\n\n\n消息队列与调度算法\n优先级队列、延迟队列、轮询调度、工作窃取（Work Stealing）；常见在 Kafka、RabbitMQ、Celery 中应用。\n\n\n限流与降级\n漏桶（Leaky Bucket）、令牌桶（Token Bucket），以及基于滑动窗口的计数算法。\n\n\n加密与安全\n对称加密（AES）、非对称加密（RSA）、数字签名、TLS 握手流程中的密钥交换算法（DH、ECDH）等。\n\n\n\n\n四、爬虫（Spider&#x2F;Crawler）专用算法\n爬取策略\n广度优先（BFS）、深度优先（DFS）、优先队列（针对聚焦爬虫，选择性爬取）。\n\n\nURL 去重与发现\n哈希（Hash）、布隆过滤器（Bloom Filter）用于海量 URL 的快速去重。\n\n\n抓取调度与并发控制\n基于异步（async&#x2F;await）、多线程&#x2F;多进程的任务队列；限速与重试策略。\n\n\nHTML 解析与数据抽取\nXPath、CSS Selector、正则表达式，必要时结合 NLP 分词／实体识别（如 jieba、spaCy）。\n\n\n抗封锁与隐匿策略\n动态代理池管理、IP 轮换；随机 UA 生成；登录／模拟行为（可选 Selenium 或 Puppeteer）。\n\n\n内容相似性检测\n文本 shingling、余弦相似度、MinHash，用于去重或判定改动增量爬取。\n\n\n\n","categories":["Backend","Java"],"tags":["后端","算法","java"]},{"title":"Java 基础教程","url":"/2025/04/27/backend/java/java%E5%9F%BA%E7%A1%80/","content":"练习:杨辉三角import java.util.Arrays;//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=&quot;Run&quot;/&gt; or// click the &lt;icon src=&quot;AllIcons.Actions.Execute&quot;/&gt; icon in the gutter.public class Main &#123;    public static void main(String[] args) &#123;        int numberOfRows = 9;        int[][] yangHuiTriangle = new int[numberOfRows][];        yangHuiTriangle[0] = new int[1];        yangHuiTriangle[0][0] = 1;        for (int i = 1; i &lt; numberOfRows; i++) &#123;            yangHuiTriangle[i] = new int[i + 1]; // 初始化当前行            for (int j = 0; j &lt; i; j++) &#123;                if (j == 0 || j == i - 1) &#123;                    yangHuiTriangle[i][j] = 1;                    continue;                &#125;                yangHuiTriangle[i][j] = yangHuiTriangle[i - 1][j - 1] + yangHuiTriangle[i - 1][j];            &#125;        &#125;        for (int[] row : yangHuiTriangle) &#123;            for (int element : row) &#123;                if (element == 0) continue;                System.out.print(element + &quot; &quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;\n\n在写杨辉三角案例的时候发现了一个二维数组初始化的问题。\n如果只初始化行的话, 二维的数组默认值是null\nint numberOfRows = 5; // 例如5行int[][] yangHuiTriangle = new int[numberOfRows][]; // 只初始化行yangHuiTriangle[0][0] = 1;\n\n如果不初始化就进行赋值的话就会报错\nException in thread &quot;main&quot; java.lang.NullPointerException: Cannot store to int array because &quot;yangHuiTriangle[0]&quot; is null\tat Main.main(Main.java:10)\n\n所以必须初始化之后在进行赋值\nint numberOfRows = 5; // 例如5行int[][] yangHuiTriangle = new int[numberOfRows][]; // 只初始化行yangHuiTriangle[0] = new int[1];yangHuiTriangle[0][0] = 1;\n\n数组初始化并赋值的2种方式\n// 方式一int[] arr = []&#123;1,2,3,4&#125;//方式二int[] arr = &#123;1,2,3,4&#125;\n\n\n\n随机数在java中有常见的两种生成随机数的方法是Math.random() 和java.util.Random类\n1. 基本用法Math.random() 方法功能: 生成[0.0,1.0)范围内的double类型的伪随机数,线程安全的\n语法:Math.ranndom()\n// 0-100int randomInt = (int)(Math.random() * 100)    // 1-30int randomInt = (int)(Math.random() * 30) + 1// 生成 [5, 20] 的随机整数（通用公式）int min = 5, max = 20;int randomInt = (int) (Math.random * (max - min + 1)) + min\n\njava.util.Random 类1. 基本用法\n功能：生成多种类型的随机数（整数、浮点数、布尔值等）。线程不安全\n语法：\n\nRandom random = new Random(); // 默认种子为系统时间Random seededRandom = new Random(123L); // 指定种子\n\n2. 核心方法\n\n\n方法\n返回值\n范围\n\n\n\nnextInt()\nint\n所有可能的 int 值\n\n\nnextInt(int bound)\nint\n[0, bound)\n\n\nnextDouble()\ndouble\n[0.0, 1.0)\n\n\nnextBoolean()\nboolean\ntrue 或 false\n\n\nnextLong()\nlong\n所有可能的 long 值\n\n\n练习:随机赋值创建一个长度为6的int型数组，要求数组元素的值都在1-30之间， 且是随机赋值。同时，要求元素的值各不相同。\nint[] arr = new int[6];for(int i = 0; i &lt; arr.length; i++)&#123;    for(int j = 0; j &lt; i; j++)&#123;        if(arr[i] == arr[j])&#123;            i--;            break;        &#125;    &#125;&#125;\n\n练习:遍历扑克牌import java.util.Arrays;public class Main &#123;    public static void main(String[] args) &#123;        String[] suit = new String[]&#123;&quot;♣&quot;, &quot;♦&quot;, &quot;♥&quot;, &quot;♠&quot;&#125;;        String[] scores = new String[]&#123;&quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;, &quot;A&quot;, &quot;2&quot;&#125;;        String[] poker = new String[56];        int total = 0;        for (int i = 0; i &lt; suit.length; i++) &#123;            for (int j = 0; j &lt; scores.length; j++) &#123;                poker[total++] = suit[i] + scores[j];            &#125;        &#125;        poker[total++] = &quot;Big Joker&quot;;        poker[total++] = &quot;Little Joker&quot;;        for (int i = 0; i &lt; total; i++) &#123;            if (i % 13 == 0 &amp;&amp; i != 0) &#123;                System.out.println();            &#125;            System.out.print(poker[i] + &quot; &quot;);        &#125;    &#125;&#125;\n\n练习: 螺旋矩阵思路分析\n1. 螺旋矩阵的特点\n螺旋矩阵是指数字从外向内顺时针螺旋排列方阵.\n我们来拿4 * 4的方阵举例\n1 → 2 → 3 → 4           ↓12 →13 →14  5↑        ↓  ↓11  16 ←15  6↑           ↓10 ←9 ←8 ←  7\n\n2. 实现思路\n我们采用”边界收缩法”来实现\n\n定义四个边界 top, bottom, left, right\n按照”上边 -&gt; 右边 -&gt; 下边 -&gt; 左边”的顺序来填充\n每填充完一条边,对应的边界像内搜索\n重复此过程直到所有数字填完\n\n\n我们先来定义一个nxn的二维数组来存放数据\n\nn = 4int num = 1;int[][] arr = new int[n][n]\n\n\n定义4条边界\n\nint top = 0, bottom = n -1, left = 0, right = n -1\n\ntop &#x3D; 0 代表上边界的第0行\nbottom &#x3D; 0 代表下边界的 最后一行\nleft &#x3D; 0  代表左边界的第 0 列\nright &#x3D; n -1 代表 右边的最后一列\n\n定义循环控制条件\n\nwhile (num &lt;= n * n) &#123;&#125;\n\n\n从左向右填充\n\nfor(int i = left; i &lt;= right;i++)&#123;  \t\tarr[left][i] = num++;&#125;  \ttop++\n\n此时我们就完成了从左到右的填充\n[​\t[1, 2, 3, 4],​   [0, 0, 0, 0], ←  top++ 将移动到这行​   [0, 0, 0, 0],​   [0, 0, 0, 0]]top++ \n\n\n从上到下填充\n\nfor(int i = top; i &lt;= bottom;i++)&#123;  \t\tarr[i][right] = num++;  \t&#125;right--\n\n此时就完成了从上到下的填充\n[​\t[1, 2, 3, 4],​   [0, 0, 0, 5], ​   [0, 0, 0, 6],​   [0, 0, 0, 7]\t\t   ↑ \t\t   right-- 此时就指向了这一列]\n\n\n从右到左填充\n\nfor(int i = right; i &gt;= left; i--)&#123;     arr[bottom][i] = num++;&#125;bottom--;\n\n此时就完成了从右到左的填充\n[​\t\t                     [1, 2, 3, 4],​  \t\t                     [0, 0, 0, 5], ​  bottom--之后指向的位置     → [0, 0, 0, 6],  ​                            [10, 9, 8, 7]]\n\n\n从下到上填充\n\nfor(int i = bottom; i &gt;= top; i--)&#123;     arr[i][left] = num++;&#125;left++;\n\n此时就填充完了一圈\n[​\t\t[1, 2, 3, 4],             ↓ 此时的left ++  ​  \t\t[12, 0, 0, 5], ​ \t\t[11, 0, 0, 6],  ​       [10, 9, 8, 7]]\n\n在填充 n轮后 到达 边界检测条件后就完成了填充 \nwhile (num &lt;= n * n) &#123;&#125;\n\n完整代码\npublic class Main &#123;    public static void main(String[] args) &#123;        int n = 4;        int[][] arr = new int[n][n];        int num = 1;        int top = 0, bottom = n - 1, left = 0, right = n - 1;        while (num &lt;= n * n) &#123;            for (int i = left; i &lt;= right; i++) &#123;                arr[top][i] = num++;            &#125;            top++;            for (int i = top; i &lt;= bottom; i++) &#123;                arr[i][right] = num++;            &#125;            right--;            for (int i = right; i &gt;= left; i--) &#123;                arr[bottom][i] = num++;            &#125;            bottom--;            for (int i = bottom; i &gt;= top; i--) &#123;                arr[i][left] = num++;            &#125;            left++;        &#125;    &#125;&#125;\n\n这套实现方法有局限性只能 做固定起点、固定顺时针的矩阵填充,不能做动态方向&#x2F;中心扩展&#x2F;不规则矩阵&#x2F;变化版螺旋布局\n第二套实现方案方向数组 + 步长控制\n实现思路和步骤\n初始化一个 3×3 的二维整型数组 matrix，用于存储结果，所有元素初始值为 0\n定义方向数组 directions，表示顺时针的移动方向：分别为「向右 (0,1)」、「向下 (1,0)」、「向左 (0,-1)」和「向上 (-1,0)」的行列偏移量。\n设置起点位置为 (row, col) = (0, 0)（矩阵左上角），并将当前方向索引 dir 初始化为 0（对应「向右」方向）\n使用 for 循环依次生成数字 1 到 9：在每次循环中，先将当前数字填入 matrix[row][col]。\n在循环内计算下一步的位置：newRow = row + directions[dir][0]，newCol = col + directions[dir][1]。\n如果 newRow 或 newCol 超出边界（&lt; 0 或 ≥ 3）或 matrix[newRow][newCol] 已经不为 0（意味着该位置已被填充），则顺时针切换方向：dir = (dir + 1) % 4，并基于新的方向重新计算 newRow、newCol。\n更新当前坐标：将 row = newRow、col = newCol，继续下一次循环\n循环结束后，使用双重 for 循环遍历并打印矩阵 matrix，即可得到完整的 3×3 螺旋矩阵结果。\npublic class SpiralMatrix &#123;    public static void main(String[] args) &#123;        // 矩阵的大小（3×3）        int n = 3;        // 初始化一个 3×3 的矩阵，默认元素值为 0        int[][] matrix = new int[n][n];        // 定义方向数组：按顺时针方向依次为「右、下、左、上」        // 对应的行列偏移量分别是 (0,1)、(1,0)、(0,-1)、(-1,0)        int[][] directions = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;        // 当前方向索引，0 表示向右        int dir = 0;        // 初始化当前坐标为左上角 (0,0)        int row = 0, col = 0;        // 使用 for 循环依次填充 1 到 n*n 的数字        for (int num = 1; num &lt;= n * n; num++) &#123;            // 将当前数字填入矩阵的当前坐标            matrix[row][col] = num;            // 计算按当前方向移动一步后的新坐标            int newRow = row + directions[dir][0];            int newCol = col + directions[dir][1];            // 如果新坐标越界或已经填充，则需要顺时针改变方向            if (newRow &lt; 0 || newRow &gt;= n || newCol &lt; 0 || newCol &gt;= n                     || matrix[newRow][newCol] != 0) &#123;                // 顺时针切换方向                dir = (dir + 1) % 4;                // 重新计算改变方向后的新坐标                newRow = row + directions[dir][0];                newCol = col + directions[dir][1];            &#125;            // 更新当前坐标为新的位置            row = newRow;            col = newCol;        &#125;        // 输出填充好的 3×3 螺旋矩阵        for (int i = 0; i &lt; n; i++) &#123;            for (int j = 0; j &lt; n; j++) &#123;                // 每个数字后跟一个制表符对齐输出                System.out.print(matrix[i][j] + &quot;\\t&quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;\n\n练习 数组反转双指针交换法\n\n循环条件：i &lt; arr.length &#x2F; 2 确保只遍历前半部分\n索引计算：arr.length - i - 1 动态计算对称位置\n交换逻辑：通过temp变量实现三数交换\n\nimport java.util.Arrays;public class Main &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;        for (int i = 0; i &lt; arr.length / 2; i++) &#123;            int temp = arr[i];            arr[i] = arr[arr.length - i - 1];            arr[arr.length - i - 1] = temp;        &#125;        System.out.println(Arrays.toString(arr));    &#125;&#125;\n\n练习 数组的扩容与缩容import java.util.Arrays;public class MyArrayList&lt;E&gt; &#123;    private Object[] data;    private int size;    private static final int INIT_CAPACITY = 10;    public MyArrayList() &#123;        data = new Object[INIT_CAPACITY];        size = 0;    &#125;    public void add(E element) &#123;        if (size == data.length) &#123;            resize(data.length * 2); // 扩容到2倍        &#125;        data[size++] = element;    &#125;    public E remove(int index) &#123;        checkIndex(index);        E oldValue = elementData(index);        int numMoved = size - index - 1;        if (numMoved &gt; 0) &#123;            System.arraycopy(data, index + 1, data, index, numMoved);        &#125;        data[--size] = null; // 让GC回收        if (size &gt; 0 &amp;&amp; size == data.length / 4) &#123;            resize(data.length / 2); // 缩容到一半        &#125;        return oldValue;    &#125;    private void resize(int newCapacity) &#123;        data = Arrays.copyOf(data, newCapacity);    &#125;    @SuppressWarnings(&quot;unchecked&quot;)    private E elementData(int index) &#123;        return (E) data[index];    &#125;    private void checkIndex(int index) &#123;        if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException();    &#125;    public int size() &#123;        return size;    &#125;&#125;\n\n\n\n","categories":["Backend","Java"],"tags":["技术","后端","查缺补漏","基础"]},{"title":"设计模式","url":"/2025/04/27/backend/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"单例模式 (Singleton)\n用途：确保一个类只有一个实例，并提供全局访问点。\n适用领域：全局状态、配置管理、数据库连接池等。\n适用语言：\n前端：JavaScript（全局状态管理、配置管理等）\n后端：Java（Spring中的单例Bean）、Python、Go、C#\n爬虫：Python、Java（爬虫管理配置、日志等）\n\n\n\n观察者模式 (Observer)\n用途：建立对象之间的一对多关系，常用于事件通知或数据更新时的自动刷新。\n适用领域：事件处理、数据绑定、状态变化等。\n适用语言：\n前端：JavaScript（如React中的状态管理、事件监听）\n后端：Java、C#、Python\n爬虫：Python（爬取任务进度更新、状态通知）\n\n\n\n模块模式 (Module)\n用途：将代码分割成多个独立模块，封装功能并通过接口暴露出去。\n适用领域：模块化编程、组件化开发。\n适用语言：\n前端：JavaScript（ES6模块、Webpack）\n后端：Node.js、Python（使用模块化组织代码）\n爬虫：Python（模块化爬虫设计）\n\n\n\n工厂模式 (Factory)\n用途：通过工厂方法动态创建对象，避免直接实例化。\n适用领域：对象创建、复杂对象实例化等。\n适用语言：\n前端：JavaScript（动态组件生成、工厂函数）\n后端：Java（Spring中使用的工厂方法）、C#、Python\n爬虫：Python（根据不同需求创建不同爬虫任务）\n\n\n\n装饰者模式 (Decorator)\n用途：动态地给对象添加额外功能，增强对象的行为。\n适用领域：功能增强、包装类等。\n适用语言：\n前端：JavaScript（事件处理、UI组件扩展）\n后端：Python、Java、C#\n爬虫：Python（数据处理时装饰器使用）\n\n\n\n命令模式 (Command)\n用途：将请求封装为对象，从而允许用户用不同的请求、队列请求或日志请求等。\n适用领域：任务调度、事件处理、撤销&#x2F;重做操作。\n适用语言：\n前端：JavaScript（操作管理、命令模式处理）\n后端：Java、C#\n爬虫：Python（请求队列管理）\n\n\n\n策略模式 (Strategy)\n用途：在运行时选择算法或行为。\n适用领域：动态选择处理方式或算法。\n适用语言：\n前端：JavaScript（UI渲染策略、数据处理）\n后端：Java（根据请求类型选择不同的处理方式）、Python、C#\n爬虫：Python（选择不同的请求方式、解析策略）\n\n\n\n代理模式 (Proxy)\n用途：通过代理控制对目标对象的访问，常用于权限控制、懒加载等。\n适用领域：访问控制、延迟加载等。\n适用语言：\n前端：JavaScript（虚拟DOM、懒加载）\n后端：Java、C#（代理控制、接口请求）\n爬虫：Python（IP代理、模拟浏览器访问）\n\n\n\n模板方法模式 (Template Method)\n用途：定义一个算法的框架，允许子类实现具体步骤。\n适用领域：框架设计、数据处理等。\n适用语言：\n前端：JavaScript（UI组件的模板方法）\n后端：Java（Spring中的模板方法）、C#\n爬虫：Python（爬虫框架设计）\n\n\n\n责任链模式 (Chain of Responsibility)\n用途：将请求沿着一条链传递，直到有处理者处理该请求。\n适用领域：多层次处理、请求的动态分发。\n适用语言：\n前端：JavaScript（事件处理链、状态管理）\n后端：Java、C#\n爬虫：Python（请求重试、数据处理链）\n\n\n\n状态模式 (State)\n用途：根据对象的当前状态动态改变其行为。\n适用领域：状态管理、流程控制。\n适用语言：\n前端：JavaScript（状态机、UI状态管理）\n后端：Java、Python、C#\n爬虫：Python（爬虫状态控制，如抓取、解析、存储）\n\n\n\n中介者模式 (Mediator)\n用途：通过中介者对象来解耦多个对象的交互，简化复杂的通信。\n适用领域：对象之间的协调与交互。\n适用语言：\n前端：JavaScript（事件总线、数据同步）\n后端：Java（消息中介、微服务通信）\n爬虫：Python（任务调度、任务协调）\n\n\n\n","categories":["Backend","Java"],"tags":["java基础"]},{"title":"数据结构","url":"/2025/04/27/backend/java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"数组 (Array)\n用途：存储多个元素，常用于列表、表格、图表等场景。\n适用领域：顺序存储多个数据。\n适用语言：\n前端：JavaScript（渲染动态列表）\n后端：Java（存储查询结果）\n爬虫：Python（存储爬取的网页 URL 列表）\n\n\n\n\n对象 (Object)\n用途：键值对结构，常用于存储具有命名属性的数据。\n适用领域：存储和管理复杂的、具名的数据。\n适用语言：\n前端：JavaScript（用户信息、配置项）\n后端：Java（用户数据、订单数据）\n爬虫：Python（存储页面元数据，如 URL、标题、内容）\n\n\n\n\n集合 (Set)\n用途：存储唯一值的集合，常用于去重。\n适用领域：去重和唯一性检验。\n适用语言：\n前端：JavaScript（去重用户输入、关键词）\n后端：Java（去重查询结果，避免重复数据）\n爬虫：Python（去重爬取的页面，避免重复抓取）\n\n\n\n\n映射 (Map)\n用途：类似于对象，但支持多种类型的键，适用于存储复杂数据。\n适用领域：存储和管理键值对数据，尤其是当键类型多样时。\n适用语言：\n前端：JavaScript（存储动态配置项、数据状态）\n后端：Java（存储用户配置信息、缓存数据）\n爬虫：Python（存储爬取任务状态、页面与链接关系）\n\n\n\n\n栈 (Stack)\n用途：后进先出（LIFO）数据结构，用于管理数据的顺序。\n适用领域：处理需要回退的操作，如撤销操作或递归任务。\n适用语言：\n前端：JavaScript（浏览器历史记录、撤销操作）\n后端：Java（任务回溯、递归处理）\n爬虫：Python（深度优先搜索，管理待爬取 URL）\n\n\n\n\n队列 (Queue)\n用途：先进先出（FIFO）数据结构，用于管理任务的顺序。\n适用领域：处理任务、消息队列等按顺序执行的任务。\n适用语言：\n前端：JavaScript（任务调度、消息队列）\n后端：Java（任务排队处理、消息系统）\n爬虫：Python（广度优先搜索，管理待爬取的 URL）\n\n\n\n\n树 (Tree)\n用途：用于组织数据的层次结构，常用于文件目录、菜单结构等。\n适用领域：表示层次结构的数据，如分类、组织架构等。\n适用语言：\n前端：JavaScript（组织目录结构、菜单）\n后端：Java（分类存储、目录树）\n爬虫：Python（页面层次结构、网站结构分析）\n\n\n\n\n图 (Graph)\n用途：表示实体之间的关系，适合复杂的多对多关系。\n适用领域：社交网络、路线图、网页链接分析等。\n适用语言：\n前端：JavaScript（社交网络图、路线图）\n后端：Java（社交网络关系、依赖关系图）\n爬虫：Python（表示网页链接关系，分析网站结构）\n\n\n\n\n链表 (Linked List)\n用途：实现高效的插入和删除操作，适合动态数据管理。\n适用领域：处理频繁修改的数据结构，动态调整。\n适用语言：\n前端：JavaScript（实现某些优化的列表操作）\n后端：Java（内存管理、缓存淘汰策略）\n爬虫：Python（临时数据存储）\n\n\n\n\n哈希表 (Hash Table)\n用途：实现高效的查找、插入和删除操作，通常用于索引、缓存。\n适用领域：快速数据查找，避免重复数据存储。\n适用语言：\n前端：JavaScript（快速查找用户数据、缓存）\n后端：Java（缓存系统、数据库索引）\n爬虫：Python（去重、存储已访问页面）\n\n\n\n\n堆 (Heap)\n用途：实现优先级队列，常用于任务调度和排序。\n适用领域：处理优先级任务，保证任务按优先级执行。\n适用语言：\n前端：JavaScript（优先级调度、任务管理）\n后端：Java（任务调度、排序）\n爬虫：Python（优先级任务调度，分布式爬虫）\n\n\n\n\n二叉搜索树 (Binary Search Tree, BST)\n用途：用于实现快速查找、插入和删除操作。\n适用领域：有序数据的存储与查找。\n适用语言：\n前端：JavaScript（排序与快速查找）\n后端：Java（数据库索引、文件系统）\n爬虫：Python（不常用，除非涉及有序数据存储）\n\n\n\n\nB+ 树 (B+ Tree)\n用途：优化查询性能，常用于数据库索引。\n适用领域：大规模数据查询优化。\n适用语言：\n前端：JavaScript（不常用）\n后端：Java（数据库索引加速查询）\n爬虫：Python（不常用）\n\n\n\n","categories":["Backend","Java"],"tags":["数据结构"]}]